%% Total Variation Optimization Script for Coherent Rytov Reconstruction
% This script applies total variation optimization to reconstructed tomograms
% generated by run_reconstruction_pipeline.m
%
% The script:
% 1. Loads RI.mat files containing RIreal and fourier_mask
% 2. Converts fourier_mask to linear indices (lims) for Fourier constraints
% 3. Applies TV optimization with FISTA algorithm
% 4. Saves optimized results as RI_reconstruction_TVpval-X_TVlambda-X.mat

clear; clc;
script_dir = fileparts(mfilename('fullpath'));
addpath(genpath(fullfile(script_dir, "utils")));

%% Load Configuration
[config_file, config_path] = uigetfile('*.json', 'Select Configuration File');
 
if isequal(config_file, 0)
    error('No configuration file selected. Exiting.');
end

config_fullpath = fullfile(config_path, config_file);

% Read and parse JSON configuration
config_text = fileread(config_fullpath);
config = jsondecode(config_text);

% Extract configuration parameters
data_dir_pattern = config.data_dir_pattern;
background_RI = config.imaging_condition.RI_bg;
wavelength = config.imaging_condition.wavelength;

%% Load TV Optimization Configuration
[lambda_config_file, lambda_config_path] = uigetfile('*.json', 'Select TV Configuration File');
if isequal(lambda_config_file, 0)
    error('TV configuration file not found. Exiting.');
end

lambda_config_full_file = fullfile(lambda_config_path, lambda_config_file);

lambda_config_text = fileread(lambda_config_full_file);
lambda_config = jsondecode(lambda_config_text);

% Extract TV parameter lists
tv_params_tv_lambda_list = reshape(lambda_config.tv_lambda_list, 1, []);
tv_params_pval_list = reshape(lambda_config.pval_list, 1, []);

% Total Variation Optimization Parameters (template)
tv_params = struct();
tv_params.lambda = 1e-0;                 % Slope of total objective function (< 1)
tv_params.tv_lambda = nan;               % Regularization parameter (will be set in loop)
tv_params.external_max_iter = 100;       % Maximum iterations for RI optimization
tv_params.internal_max_iter = 100;       % Maximum iterations for TV proximal calculation
tv_params.pval = nan;                    % Choice of L1 TV or L2 TV (will be set in loop)

%% Find reconstruction directories and apply TV optimization

sample_dirs = dir(data_dir_pattern);
sample_dirs = sample_dirs([sample_dirs.isdir]);
sample_dirs = sample_dirs(~ismember({sample_dirs.name}, {'.', '..'}));

task_count = 0;
for i = 1:length(sample_dirs)
    sample_path = fullfile(sample_dirs(i).folder, sample_dirs(i).name);
    
    % Check for existing reconstruction file
    reconstruction_file = fullfile(sample_path, 'RI.mat');
    if ~isfile(reconstruction_file)
        fprintf('[%d/%d] Skipping "%s" - RI.mat not found\n', i, length(sample_dirs), sample_dirs(i).name);
        continue;
    end

    % Load reconstruction data once
    recon_data = load(reconstruction_file);
    RIreal = recon_data.RIreal;
    resolution = recon_data.resolution;
    fourier_mask = recon_data.fourier_mask;
    
    % Convert fourier_mask to linear indices (lims)
    % fourier_mask >= 1 creates a logical mask
    lims = find(fourier_mask >= 1);
    
    % Execute TV optimization
    for tv_lambda = tv_params_tv_lambda_list
        for pval = tv_params_pval_list
            tv_params.tv_lambda = tv_lambda;
            tv_params.pval = pval;
            % Check if TV optimized file already exists
            tv_output_file = fullfile(sample_path, sprintf('RI_reconstruction_TVpval-%d_TVlambda-%.1e.mat', tv_params.pval, tv_params.tv_lambda));
            if isfile(tv_output_file)
                fprintf('Skipping - TV optimized file "%s" already exists\n', tv_output_file);
                continue;
            end
            % Load reconstruction data
            fprintf('  Loading reconstruction data...\n');
            if ~exist('recon_data', 'var')
                recon_data = load(reconstruction_file);
                original_RIreal = recon_data.RIreal;
                RIreal = original_RIreal( ...
                    (1 + pre_crop_size(1)):(end - post_crop_size(1)), ...
                    (1 + pre_crop_size(2)):(end - post_crop_size(2)), ...
                    (1 + pre_crop_size(3)):(end - post_crop_size(3))  ...
                );
                resolution = recon_data.resolution;
            end
            % Apply Total Variation Optimization
            fprintf('  Applying TV optimization...\n');
            task_start = tic;
            RIreal_tv = apply_tv_optimization(RIreal, tv_params, lims, background_RI, config.run_on_gpu);
            fprintf('  Optimization completed in %.2f seconds\n', toc(task_start));
            % Save TV optimized result
            fprintf('  Saving Results...\n');
            save(tv_output_file, 'RIreal_tv', 'resolution', 'tv_params', '-v7.3');
            task_count = task_count + 1;
        end
    end
    clear recon_data
end

%% Total Variation Optimization Function
function RIreal_optimized = apply_tv_optimization(RIreal, params, lims, background_RI, run_on_gpu)
    % Total variation optimization using same projection as tomogram reconstruction
    %
    % Inputs:
    %   RIreal - 3D refractive index data from reconstruction
    %   params - structure containing optimization parameters
    %   lims - Linear indices for Fourier space support
    %   background_RI - background refractive index value
    %
    % Outputs:
    %   RIreal_optimized - TV optimized refractive index data
    arguments
        RIreal 
        params 
        lims 
        background_RI 
        run_on_gpu = false
    end

    % convert RIreal -> Vreal = (n(r)^2/n_m^2 - 1)
    Vreal = RIreal.^2/background_RI.^2 -1;
    % prepare initialized arrays
    Vreal_optimized = Vreal;

    % Store reference Fourier coefficients at support locations
    Vreal_fourier = gather(fftn(gpuArray(Vreal_optimized)));
    Vreal_fourier_proj = Vreal_fourier(lims);
    lambda = params.lambda;
    w = lambda * params.tv_lambda;
    tv_reg = LpTotalVariation(w, params.pval, params.internal_max_iter);
    t_np = 1;
    V_np = Vreal;

    % Optimization loop using FISTA with Fourier domain constraints
    for iter = 1:params.external_max_iter
        t_n = t_np;
        V_n = V_np;

        % Gradient step: enforce Fourier domain constraints at support locations
        % This projects the current estimate onto the subspace defined by the measurements
        % Gradient of 1/2||P(x - x0)||^2 is P^T*P(x - x0) = P(x - x0) since P is projection
        % Update: x_(k+1) = x_k - lambda * P(x_k - x0) = (1-lambda)*x_k + lambda*P*x0
        % start GPU calculation
        Vreal_fourier = gather(fftn(gpuArray(Vreal_optimized)));
        Vreal_fourier(lims) = (1-lambda) .* Vreal_fourier(lims) + lambda .* Vreal_fourier_proj;
        Vreal_optimized = ifftn(gpuArray(Vreal_fourier), 'symmetric');
        if ~run_on_gpu
            Vreal_optimized = gather(Vreal_optimized);
        end
        
        % Proximal step: apply TV regularization
        V_np(:) = gather(tv_reg.proximal(Vreal_optimized));
        % end GPU calculation

        % FISTA acceleration step
        t_np = (1+sqrt(1+4*t_n^2))/2;
        Vreal_optimized(:) = V_np + ((t_n-1)/(t_np))*(V_np - V_n);
    end
    % convert Vreal_optimized -> RIreal_optimized
    RIreal_optimized = gather(background_RI .* sqrt(Vreal_optimized + 1));
end